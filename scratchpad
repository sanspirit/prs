output "private_endpoint_name" {
  description = "The name of the Private Endpoint associated with this SQL Server instance."
  value       = azurerm_private_endpoint.pe.name
}

pass to a data block (data source) to get the actual pe resource back so you can get the ip

locals {
  sql_db_name = lower("${module.naming.standard["sql-database"]}-sql${local.hyphenated_name_suffix}")

  sql_server   = data.azurerm_mssql_server.sql_server.fully_qualified_domain_name
  sql_identity = var.identity_to_assign
  sql_role     = var.access_role_to_assign
}

resource "azurerm_mssql_database" "sql_database" {
  name           = local.sql_db_name
  server_id      = data.azurerm_mssql_server.sql_server.id
  collation      = var.database_collation
  license_type   = var.license_type
  max_size_gb    = var.database_max_size_gb
  sku_name       = var.database_sku
  zone_redundant = var.database_zone_redundant
  tags           = var.tags

  lifecycle {
    ignore_changes = [
      tags
    ]
  }
}

# This rule allows ADO to access the SQL database
resource "azurerm_network_security_rule" "allow-ado-inbound-sql-integration" {
  name                                  = "Allow-ADO-Agents-Inbound-SQL"
  priority                              = 1000
  direction                             = "Inbound"
  access                                = "Allow"
  protocol                              = "Tcp"
  source_port_range                     = "*"
  destination_port_ranges               = ["443", "1433"]
  source_application_security_group_ids = [asg-ado]
  destination_address_prefix            = module.sql_database.address_prefix
  resource_group_name                   = var.vnet_resource_group_name
  network_security_group_name           = module.sql_database.network_security_group_name
}

resource "null_resource" "set_permissions" {
  triggers = {
    always_run = timestamp() # Will run every time
  }

  provisioner "local-exec" {
    command     = ".'${path.module}\\scripts\\Set_Permissions.ps1'"
    interpreter = ["pwsh", "-Command"]
    environment = {
      SQL_SERVER   = local.sql_server,
      SQL_IDENTITY = local.sql_identity,
      SQL_DATABASE = local.sql_db_name,
      SQL_ROLE     = local.sql_role
    }
  }

  depends_on = [azurerm_mssql_database.sql_database]
}


var shasumInfoList = blobPathList
      .Where(path => (!(path.EndsWith(".sig")) || !(path.EndsWith(".zip")))
      .Select(path =>
      {
          var blobparts = path.Split('/');
          return new ProviderPackageInfo
          {
              VersionType = blobparts[3],
              Version = blobparts[4],
              OS = blobparts[5],
              Arch = blobparts[6],
              Filename = blobparts[7],

          };
      })
      .Distinct()
      .ToList();

public ProviderPackageJson GetProviderPackage(string path)
{
    var pack = new Package();
    pack.packageversions = new List<ProviderPackage>();

    var parts = path.Split('/');
    var registryUrl = GetDownloadUriAsync(path);
    var uriString = registryUrl.Result.ToString().Split("?");
    var packageinfo = new ProviderPackage();

    packageinfo.Os = parts[6];
    packageinfo.Arch = parts[7];
    packageinfo.ProviderVersion = parts[5];
    packageinfo.ProviderType = parts[4];
    var blobPath = "v1/providers/" + parts[3] + "/";
    List<string> blobPathList = new List<string>();
    blobPathList = _providerRepository.GetPathList(blobPath);

   var zipInfoList = blobPathList
        .Where(path => path.EndsWith(".zip"))
        .Select(path =>
        {
            var blobparts = path.Split('/');
            return new ProviderPackageInfo
            {
                VersionType = blobparts[3],
                Version = blobparts[4],
                OS = blobparts[5],
                Arch = blobparts[6],
                Filename = blobparts[7],
              
            };
        })
        .Distinct()
        .ToList();

    var zipPackage = zipInfoList
        .Where(providerpackageInfo =>
            packageinfo.ProviderType == providerpackageInfo.VersionType &&
            packageinfo.ProviderVersion == providerpackageInfo.Version &&
            packageinfo.Os == providerpackageInfo.OS &&
            packageinfo.Arch == providerpackageInfo.Arch)
        .FirstOrDefault(); // Use FirstOrDefault to get the matching version info

    if (zipPackage != null)
    {
        packageinfo.Filename = zipPackage.Filename;
        packageinfo.DownloadUrl = uriString[0] + packageinfo.Filename;
       //pack.packageversions.Add(packageinfo);
    }
    else
    {
        throw new FileNotFoundException("The requested package was not found.", path);
    }

    
    
    
        List<string> ShasumsUrlPathList = new List<string>();
    //ShasumsUrlPathList = _providerRepository.GetPathList(blobPath);
    var sigInfoList = blobPathList
     .Where(path => path.EndsWith(".sig"))
     .Select(path =>
     {
         var blobparts = path.Split('/');
         return new ProviderPackageInfo
         {
             VersionType = blobparts[3],
             Version = blobparts[4],
             OS = blobparts[5],
             Arch = blobparts[6],
             ShasumsSignatureUrl = blobparts[7]
         
         };
     })
     .Distinct()
     .ToList();

    var sigPackage = sigInfoList
        .Where(providerpackageInfo =>
            packageinfo.ProviderType == providerpackageInfo.VersionType &&
            packageinfo.ProviderVersion == providerpackageInfo.Version &&
            packageinfo.Os == providerpackageInfo.OS &&
            packageinfo.Arch == providerpackageInfo.Arch);
    //.FirstOrDefault(); // Use FirstOrDefault to get the matching version info

    if (sigPackage != null)
    {
        packageinfo.ShasumsSignatureUrl = sigPackage.Where(ProviderPackageInfo.Equals);
        packageinfo.ShasumsUrl = sigPackage.ShasumsUrl;

        //pack.packageversions.Add(packageinfo);

    }

    pack.packageversions.Add(packageinfo);

    var json = new ProviderPackageJson();
    json.packages = new List<Package> { pack };

    return json;
}

public ProviderPackageJson GetProviderPackage(string path)
 {
     var pack = new Package();
     pack.packageversions = new List<ProviderPackage>();

     var parts = path.Split('/');
     var registryUrl = GetDownloadUriAsync(path);
     var uriString = registryUrl.Result.ToString().Split("?");
     var packageinfo = new ProviderPackage();

     packageinfo.Os = parts[6];
     packageinfo.Arch = parts[7];
     packageinfo.ProviderVersion = parts[5];
     packageinfo.ProviderType = parts[4];
     var blobPath = "v1/providers/" + parts[3] + "/";
     List<string> blobPathList = new List<string>();
     blobPathList = _providerRepository.GetPathList(blobPath);

    var zipInfoList = blobPathList
         .Where(path => path.EndsWith(".zip"))
         .Select(path =>
         {
             var blobparts = path.Split('/');
             return new ProviderPackageInfo
             {
                 VersionType = blobparts[3],
                 Version = blobparts[4],
                 OS = blobparts[5],
                 Arch = blobparts[6],
                 Filename = blobparts[7],
               
             };
         })
         .Distinct()
         .ToList();

     var zipPackage = zipInfoList
         .Where(providerpackageInfo =>
             packageinfo.ProviderType == providerpackageInfo.VersionType &&
             packageinfo.ProviderVersion == providerpackageInfo.Version &&
             packageinfo.Os == providerpackageInfo.OS &&
             packageinfo.Arch == providerpackageInfo.Arch)
         .FirstOrDefault(); // Use FirstOrDefault to get the matching version info

     if (zipPackage != null)
     {
         packageinfo.Filename = zipPackage.Filename;
         packageinfo.DownloadUrl = uriString[0] + packageinfo.Filename;
        //pack.packageversions.Add(packageinfo);
     }
     else
     {
         throw new FileNotFoundException("The requested package was not found.", path);
     }

     
     
     
         List<string> ShasumsUrlPathList = new List<string>();
     //ShasumsUrlPathList = _providerRepository.GetPathList(blobPath);
     var sigInfoList = blobPathList
      .Where(path => path.EndsWith(".sig"))
      .Select(path =>
      {
          var blobparts = path.Split('/');
          return new ProviderPackageInfo
          {
              VersionType = blobparts[3],
              Version = blobparts[4],
              OS = blobparts[5],
              Arch = blobparts[6],
              ShasumsSignatureUrl = blobparts[7]
              // ShasumsUrl = blobparts[8],
              // ShasumsSignatureUrl = blobparts[9]
          };
      })
      .Distinct()
      .ToList();

     var sigPackage = sigInfoList
         .Where(providerpackageInfo =>
             packageinfo.ProviderType == providerpackageInfo.VersionType &&
             packageinfo.ProviderVersion == providerpackageInfo.Version &&
             packageinfo.Os == providerpackageInfo.OS &&
             packageinfo.Arch == providerpackageInfo.Arch);
     //.FirstOrDefault(); // Use FirstOrDefault to get the matching version info

     if (sigPackage != null)
     {
         packageinfo.ShasumsSignatureUrl = sigPackage.ShasumsSignatureUrl.ToString();
         packageinfo.ShasumsUrl = sigPackage.ShasumsSignatureUrl.ToString();

         //pack.packageversions.Add(packageinfo);
         
     }

     pack.packageversions.Add(packageinfo);

     var json = new ProviderPackageJson();
     json.packages = new List<Package> { pack };

     return json;
 }




https://registry.terraform.io/v1/providers/hashicorp/azurerm/3.75.0/download/windows/amd64


[HttpGet("v1/providers/{nameSpace}/{type}/{version}/download/{os}/{arch}")]
  public ProviderPackageJson FindProviderPackage(string nameSpace, string type, string version, string os, string arch)
  {
      Response.ContentType = "application/json";
      return _providerService.GetProviderPackage($"/v1/providers/{nameSpace}/{type}/{version}/{os}/{arch}/");
  }

public ProviderPackageJson GetProviderPackage(string path)
        {
                     

            var pack = new Package();
            pack.packageversions = new List<ProviderPackage>();

            var parts = path.Split('/');
            var registryUrl = GetDownloadUriAsync(path);
            var uriString = registryUrl.Result.ToString().Split("?");
            var packageinfo = new ProviderPackage();

            packageinfo.Os = parts[6];
            packageinfo.Arch = parts[7];
            packageinfo.ProviderVersion = parts[5];
            packageinfo.ProviderType = parts[4];
            var blobPath = "v1/providers/" + parts[3] + "/" ;
            List<string> blobPathList = new List<string>();
            blobPathList = _providerRepository.GetPathList(blobPath);

            var versionInfoList = blobPathList
                .Where(path => path.EndsWith(".zip"))
                .Select(path =>
                {
                    var blobparts = path.Split('/');
                    return new VersionInfo
                    {
                        VersionType = blobparts[3],
                        Version = blobparts[4],
                        OS = blobparts[5],
                        Arch = blobparts[6],
                        Filename = blobparts[7]
                    };
                })
                .Distinct()
                .ToList();
            var requiredPackageList = versionInfoList
         .Where(versionInfo =>
        packageinfo.ProviderType == versionInfo.VersionType &&
        packageinfo.ProviderVersion == versionInfo.Version &&
        packageinfo.Os == versionInfo.OS &&
        packageinfo.Arch == versionInfo.Arch)
    .Distinct()
    .Select(versionInfo => new
    {
        VersionType = versionInfo.VersionType,
        Version = versionInfo.Version,
        OS = versionInfo.OS,
        Arch = versionInfo.Arch,
        FileName  = versionInfo.Filename
    })
    .Distinct()
    .ToList();


            packageinfo.Filename = requiredPackageList.FileName;
            //packageinfo.Filename = "terraform" + "-" + "provider" + "-" + parts[4] + "_" + parts[5] + "_" + packageinfo.Os + "_" + packageinfo.Arch +".zip";
            packageinfo.DownloadUrl += uriString[0] + packageinfo.Filename;
            pack.packageversions.Add(packageinfo);
                

            var json = new ProviderPackageJson();
            json.packages = new List<Package> { pack };
            
            return json;
            
        }

        public ProviderPackageJson GetProviderPackage(string path)
        {
                     

            var pack = new Package();
            pack.packageversions = new List<ProviderPackage>();

            var parts = path.Split('/');
            var registryUrl = GetDownloadUriAsync(path);
            var uriString = registryUrl.Result.ToString().Split("?");
            var packageinfo = new ProviderPackage();

            packageinfo.Os = parts[6];
            packageinfo.Arch = parts[7];
            packageinfo.ProviderVersion = parts[5];
            packageinfo.ProviderType = parts[4];
            var blobPath = "v1/providers/" + parts[3] + "/" ;
            List<string> blobPathList = new List<string>();
            blobPathList = _providerRepository.GetPathList(blobPath);

            var versionInfoList = blobPathList
                .Where(path => path.EndsWith(".zip"))
                .Select(path =>
                {
                    var blobparts = path.Split('/');
                    return new VersionInfo
                    {
                        VersionType = blobparts[3],
                        Version = blobparts[4],
                        OS = blobparts[5],
                        Arch = blobparts[6],
                    };
                })
                .Distinct()
                .ToList();
            var requiredPackageList = versionInfoList
         .Where(versionInfo =>
        packageinfo.ProviderType == versionInfo.VersionType &&
        packageinfo.ProviderVersion == versionInfo.Version &&
        packageinfo.Os == versionInfo.OS &&
        packageinfo.Arch == versionInfo.Arch)
    .Distinct()
    .Select(versionInfo => new
    {
        VersionType = versionInfo.VersionType,
        Version = versionInfo.Version,
        OS = versionInfo.OS,
        Arch = versionInfo.Arch,
        FileName  = versionInfo.Filename
    })
    .Distinct()
    .ToList();


            packageinfo.Filename = requiredPackageList.FileName;
            //packageinfo.Filename = "terraform" + "-" + "provider" + "-" + parts[4] + "_" + parts[5] + "_" + packageinfo.Os + "_" + packageinfo.Arch +".zip";
            packageinfo.DownloadUrl += uriString[0] + packageinfo.Filename;
            pack.packageversions.Add(packageinfo);
                

            var json = new ProviderPackageJson();
            json.packages = new List<Package> { pack };
            
            return json;
            
        }

        public ProviderPackageJson GetProviderPackage(string path)
        {
                     

            var pack = new Package();
            pack.packageversions = new List<ProviderPackage>();

            var parts = path.Split('/');
            var registryUrl = GetDownloadUriAsync(path);
            var uriString = registryUrl.Result.ToString().Split("?");
            var packageinfo = new ProviderPackage();

            packageinfo.Os = parts[6];
            packageinfo.Arch = parts[7];
            packageinfo.ProviderVersion = parts[5];
            packageinfo.ProviderType = parts[4];
            var blobPath = "v1/providers/" + parts[3] + "/" ;
            List<string> blobPathList = new List<string>();
            blobPathList = _providerRepository.GetPathList(blobPath);

            var versionInfoList = blobPathList
                .Where(path => path.EndsWith(".zip"))
                .Select(path =>
                {
                    var blobparts = path.Split('/');
                    return new VersionInfo
                    {
                        VersionType = blobparts[3],
                        Version = blobparts[4],
                        OS = blobparts[5],
                        Arch = blobparts[6],
                    };
                })
                .Distinct()
                .ToList();
            var requiredPackageList = versionInfoList
         .Where(versionInfo => packageinfo.ProviderType == versionInfo.VersionType && packageinfo.ProviderVersion == versionInfo.Version && packageinfo.Os == versionInfo.OS && packageinfo.Arch == versionInfo.Arch )
         .Select(versionInfo => versionInfo.*)
         .Distinct()
         .ToList();



            packageinfo.Filename = "terraform" + "-" + "provider" + "-" + parts[4] + "_" + parts[5] + "_" + packageinfo.Os + "_" + packageinfo.Arch +".zip";
            packageinfo.DownloadUrl += uriString[0] + packageinfo.Filename;
            pack.packageversions.Add(packageinfo);
                

            var json = new ProviderPackageJson();
            json.packages = new List<Package> { pack };
            
            return json;
            
        }

using Azure.Storage.Blobs.Models;
using Azure.Storage.Blobs;
using Azure;
using Markdig.Helpers;
using RoyalLondon.TerraformRegistry.Api.src.Models;
using System;
using System.IO;

namespace RoyalLondon.TerraformRegistry.Api.src.Models
{
    public class ProviderService
    {
        private readonly IProviderRepository _providerRepository;

        public ProviderService(IProviderRepository providerRepository)
        {
            _providerRepository = providerRepository;
        }

        //Creates a JSON response listing all the versions of a specified provider
        public ProviderVersionsJson GetVersionList(string path)
        {

            var versionPathList = _providerRepository.GetPathList(path);

            var versionInfoList = versionPathList
                .Where(path => path.EndsWith(".zip"))
                .Select(path =>
                {
                    var parts = path.Split('/');
                    return new VersionInfo
                    {
                        Version = parts[4],
                        OS = parts[5],
                        Arch = parts[6],
                    };
                })
                .Distinct()
                .ToList();

            var groupedVersions = versionInfoList
                .GroupBy(info => info.Version)
                .Select(group => new ProviderVersion
                {
                    version = group.Key,
                    protocols = _providerRepository.GetBlobMetadata(path),
                    platforms = group.Select(info => new ProviderPlatform
                    {
                        os = info.OS,
                        arch = info.Arch
                    }).ToList()
                })
                .ToList();

            var json = new ProviderVersionsJson
            {
                providers = new List<Provider> { new Provider { versions = groupedVersions } }
            };

            return json;
        }

                
        public ProviderPackageJson GetProviderPackage(string path)
        {
            var groupedpackageVersions = _providerRepository.GetPathList(path);
            var json = new ProviderPackageJson
            {
                packages = new List<Package> { new Package {  } }
            };

            return json;
        }

        public async Task<string> GetDownloadUriAsync(string path)
        {
            var sasUri = await _providerRepository.GetSasUriAsync();
            var uriString = sasUri.ToString().Split("?");
            uriString[0] += path + "?";
            sasUri = new Uri(uriString[0] + uriString[1]); //Adds provider location to the sas uri

            return sasUri.ToString();
        }

        //Creates a list of namespaces, modules, providers, or versions depending on user input from the GUI
        public List<string> GetProviderData(string path)
        {
            var pathList = _providerRepository.GetPathList(path);
            List<string> unique = new List<string>();
            int start = path.Length;
            foreach (var blob in pathList)
            {
                int total = blob.Length;
                string stringBack = blob[start..total];
                int end = stringBack.IndexOf('/');
                if (end > 0)
                {
                    string word = stringBack[0..end];
                    unique.Add(word);
                }
            }
            return unique.Distinct().ToList();
        }

        public string GetReadMeContent(string filepath)
        {
            return _providerRepository.GetReadMeContent(filepath);
        }
    }
}

namespace RoyalLondon.TerraformRegistry.Api.src.Models
{

    public class ProviderVersion
    {
        public string version { get; set; }
        public IDictionary<string, string> protocols { get; set; }
        public List<ProviderPlatform> platforms { get; set; }
    }

    public class Provider
    {
        public IList<ProviderVersion> versions { get; set; }
    }

    public class ProviderVersionsJson
    {
        public IList<Provider> providers { get; set; }
    }

    public class ProviderPlatform
    {
        public string os { get; set; }
        public string arch { get; set; }
    }

    public class VersionInfo
    {
        public string Version { get; set; }
        public string OS { get; set; }
        public string Arch { get; set; }
    }


    public class ProviderPackageJson
    {
        public IList<Package> packages { get; set; }
    }

    public class Package
    {
        public IList<ProviderPackage> packageversions { get; set; }
    }
    public class ProviderPackage
    {
        public List<string> Protocols { get; set; }
        public string Os { get; set; }
        public string Arch { get; set; }
        public string Filename { get; set; }
        public string DownloadUrl { get; set; }
        public string ShasumsUrl { get; set; }
        public string ShasumsSignatureUrl { get; set; }
        public string Shasum { get; set; }
        public SigningKeys SigningKeys { get; set; }
    }

    public class SigningKeys
    {
        public List<GpgPublicKey> GpgPublicKeys { get; set; }
    }

    public class GpgPublicKey
    {
        public string KeyId { get; set; }
        public string AsciiArmor { get; set; }
        public string TrustSignature { get; set; }
        public string Source { get; set; }
        public string SourceUrl { get; set; }
    }
}




















Add a smoke test which uploads a provider to the TF registry and then successfully does a `terraform init` which downloads that provider from the Terraform Registry.
https://hugomartins.io/essays/2021/01/build-a-terraform-private-registry/

https://releases.hashicorp.com/terraform-provider-azurerm/3.75.0/terraform-provider-azurerm_3.75.0_windows_amd64.zip

param (
    [Parameter(Mandatory)]
    [string] $StorageAccountName,
    [Parameter(Mandatory)]
    [string] $ContainerName,
    [Parameter(Mandatory)]
    [string] $TerraformRegistryFqdn
)

Describe "Terraform Registry API" {
    It "'terraform init' should return an exit code of 0 (successful)" {
        # Arrange

        # 1. Zip the test module - it's important that we use GNU zip as this is what's
        # used in the module release pipeline; we've seen funny behaviour from the Compress-Archive cmdlet
        # zip terraform-provider-azurerm_3.75.0_windows_amd64.zip "test-provider/main.tf"
        # Define the URL and the destination path
        $url = "https://releases.hashicorp.com/terraform-provider-azurerm/3.75.0/terraform-provider-azurerm_3.75.0_windows_amd64.zip"
        $destinationPath = Join-Path -Path $PSScriptRoot -ChildPath "test-provider\terraform-provider-azurerm_3.75.0_windows_amd64.zip"

        # Create the destination directory if it doesn't exist
        #$destinationDirectory = Split-Path $destinationPath
        #New-Item -ItemType Directory -Force -Path $destinationDirectory

        # Download the file
        Invoke-WebRequest -Uri $url -OutFile $destinationPath

        # 2. Upload the test module zip to the TF registry storage account
        $context = New-AzStorageContext -StorageAccountName $StorageAccountName
        $blobName = "v1/providers/royallondon/azurerm/3.75.0/download/windows/amd64/terraform-provider-azurerm_3.75.0_windows_amd64.zip"
        Set-AzStorageBlobContent `
            -Container $ContainerName `
            -File "terraform-provider-azurerm_3.75.0_windows_amd64.zip" `
            -Blob $blobName `
            -Context $context `
            -Force

        # 3. Substitute placeholder token with TF registry URL in the consuming main.tf
        $testHarnessMainFilePath = "test-provider/main.tf"
        (Get-Content -Raw $testHarnessMainFilePath) -replace "TERRAFORM_REGISTRY_FQDN", $TerraformRegistryFqdn | Set-Content $testHarnessMainFilePath

        # Act
        terraform -chdir=test-provider init -input=false -backend=false
        $terraformInitExitCode = $LASTEXITCODE

        # Assert
        $terraformInitExitCode | Should -Be 0 -Because "'terraform init' should succeed"

        # Teardown
        Remove-AzStorageBlob -Container $ContainerName -Blob $blobName -Context $context
    }
}





using System;
using System.IO;
using Microsoft.AspNetCore.Mvc;
using Newtonsoft.Json;

[Route("v1/providers")]
public class ProviderController : Controller
{
    [HttpGet("{namespace}/{name}/{version}/download/{os}/{arch}")]
    public IActionResult DownloadPackage(string @namespace, string name, string version, string os, string arch)
    {
        string filepath = $"providers/{@namespace}/{name}.json";
        
        if (!System.IO.File.Exists(filepath))
        {
            return NotFound();
        }

        string jsonContent = System.IO.File.ReadAllText(filepath);
        var data = JsonConvert.DeserializeObject<ProviderData>(jsonContent);
        
        ProviderInfo provider = null;

        foreach (var elem in data.Versions)
        {
            if (elem.Version == version)
            {
                foreach (var platform in elem.Platforms)
                {
                    if (platform.OS == os && platform.Arch == arch)
                    {
                        provider = platform;
                        provider.Protocols = elem.Protocols;
                    }
                }
            }
        }

        if (provider == null)
        {
            return NotFound();
        }

        return Json(provider);
    }
}

public class ProviderData
{
    public List<ProviderVersion> Versions { get; set; }
}

public class ProviderVersion
{
    public string Version { get; set; }
    public List<ProviderPlatform> Platforms { get; set; }
    public List<string> Protocols { get; set; }
}

public class ProviderPlatform
{
    public string OS { get; set; }
    public string Arch { get; set; }
    // Add any other properties you need here
}

-------------------------------

 [HttpGet("v1/Providers/{nameSpace}/{type}/versions")]
 public ProviderVersionsJson GetVersionList(string nameSpace, string type)
 {
     Response.ContentType = "application/json";
     return _providerService.GetVersionList($"v1/providers/{nameSpace}/{type}/");
 }
--------------------------------

namespace TerraformRegistry.Api.src.Models
{
    public class ProviderVersion
    {
        public string version { get; set; }
        public List<ProviderPlatform> Platforms { get; set; }
        public List<string> Protocols { get; set; }
    }

    public class Provider
    {
        public IList<ProviderVersion> versions { get; set; }
    }

    public class ProviderVersionsJson
    {
        public IList<Provider> providers { get; set; }
    }
    public class ProviderPlatform
    {
        public string OS { get; set; }
        public string Arch { get; set; }
       
    }
}

------------

        public ProviderVersionsJson GetVersionList(string path)
        {
            var versionPathList = _providerRepository.GetPathList(path);

            var provider = new Provider();
            provider.versions = new List<ProviderVersion>();
            HashSet<string> uniqueSet = new HashSet<string>();

            foreach (var versionPath in versionPathList)
            {
                if (versionPath.EndsWith(".zip"))
                {
                    var version = new ProviderVersion();
                    version.version = versionPath.Split("/")[4];
                                      
                    if (uniqueSet.Add(version.version))
                    {
                       
                        provider.versions.Add(version);
                    }


                }
               
                /* commented
                foreach (var elem in provider.versions)
                {
                   // if (elem.Version == version)
                    //{
                        foreach (var platform in elem.Platforms)
                        {
                            if (platform.OS == os && platform.Arch == arch)
                            {
                                provider = platform;
                                provider.Protocols = elem.Protocols;
                            }
                        }
                    }
                }

                */
            }



            var json = new ProviderVersionsJson();
            json.providers = new List<Provider> { provider };

            return json;
        }

File paths:
v1/providers/namespace/azurerm/3.75.0/windows/amd64/local.zip
v1/providers/namespace/azurerm/3.75.0/freebsd/386/local.zip
v1/providers/namespace/azurerm/3.75.0/linux/arm/local.zip
v1/providers/namespace/azurerm/3.76.0/darwin/arm64/local.zip
v1/providers/namespace/azurerm/3.76.0/windows/amd64/local.zip


Jason Output:
{
  "versions": [
    {
      "version": "3.75.0",
      "protocols": [null, null],
      "platforms": [
        {"os": "darwin", "arch": "amd64"},
        {"os": "linux", "arch": "arm"},
        {"os": "windows", "arch": "amd64"}
      ]
    },
    {
      "version": "3.76.0",
      "protocols": [null],
      "platforms": [
        {"os": "darwin", "arch": "amd64"},
       {"os": "windows", "arch": "amd64"}
      ]
    }
  ]
}


namespace RoyalLondon.TerraformRegistry.Api.src.Models
{
    public class AzureStorageProviderRepository : IProviderRepository
    {
        private readonly BlobServiceClient _blobServiceClient;
        private readonly IConfiguration _configuration;
        private readonly MarkdownPipeline markdownPipeline;
        private string ContainerName
        {
            get => _configuration["AZCONTAINER"] ?? throw new ConfigurationNotFoundException("AZCONTAINER");
        }

        public AzureStorageProviderRepository(BlobServiceClient blobServiceClient, IConfiguration configuration)
        {
            _blobServiceClient = blobServiceClient;
            _configuration = configuration;
            markdownPipeline = new MarkdownPipelineBuilder().UsePipeTables().UseAdvancedExtensions().Build();
        }

        //Returns a list of paths from a blob container that begin with the subPath
        public List<string> GetPathList(string subPath)
        {
            List<string> pathList = new List<string>();
            var paths = _blobServiceClient.GetBlobContainerClient(ContainerName).GetBlobs(BlobTraits.None, BlobStates.None, subPath);
            foreach (var path in paths) //Coverting Pageable<BlobItem> to List<string>
            {
                pathList.Add(path.Name);
            }

            return pathList;
        }

        //Returns a uri with a SAS token to allow downloading from the blob container
        public async Task<Uri> GetSasUriAsync()
        {
            var blobClient = _blobServiceClient.GetBlobContainerClient(ContainerName);
            var userDelegationKey = await _blobServiceClient.GetUserDelegationKeyAsync(DateTimeOffset.UtcNow, DateTimeOffset.UtcNow.AddMinutes(5));
            BlobSasBuilder sasBuilder = new BlobSasBuilder()
            {
                BlobContainerName = ContainerName,
                Resource = "b", //resource is a blob
                StartsOn = DateTimeOffset.UtcNow,
                ExpiresOn = DateTimeOffset.UtcNow.AddMinutes(5),
            };

            sasBuilder.SetPermissions(BlobSasPermissions.Read);

            BlobUriBuilder uriBuilder = new BlobUriBuilder(blobClient.Uri)
            {
                Sas = sasBuilder.ToSasQueryParameters(userDelegationKey, blobClient.GetParentBlobServiceClient().AccountName)
            };

            return uriBuilder.ToUri();
        }

        //Returns content from a readme file and converts it from markdown to html
        public string GetReadMeContent(string filepath)
        {
            var blobClient = _blobServiceClient.GetBlobContainerClient(ContainerName).GetBlobClient(filepath);
            var data = "<p style='color: red;'>No readme file found for this version.</p>";//html to be displayed if no readme file found
            try
            {
                data = Markdown.ToHtml(blobClient.DownloadContent().Value.Content.ToString(), markdownPipeline);
            }
            catch (RequestFailedException rfe)
            {
                Console.Error.WriteLine($"{filepath} - {rfe.Message}");
                data = $"{filepath} - {rfe.Message}";
            }
            return data;
        }
    }
}

public ProviderVersionsJson GetVersionList(string path)
{

    var versionPathList = _providerRepository.GetPathList(path);

    var versionInfoList = versionPathList
        .Where(path => path.EndsWith(".zip"))
        .Select(path =>
        {
            var parts = path.Split('/');
            return new VersionInfo
            {
                Version = parts[4],
                OS = parts[5],
                Arch = parts[6],
            };
        })
        .Distinct()
        .ToList();

    var groupedVersions = versionInfoList
        .GroupBy(info => info.Version)
        .Select(group => new ProviderVersion
        {
            version = group.Key,
            protocols = new List<string> { null }, 
            platforms = group.Select(info => new ProviderPlatform
            {
                os = info.OS,
                arch = info.Arch
            }).ToList()
        })
        .ToList();

    var json = new ProviderVersionsJson
    {
        providers = new List<Provider> { new Provider { versions = groupedVersions } }
    };

    return json;
}

https://developer.hashicorp.com/terraform/internals/provider-registry-protocol#find-a-provider-package
